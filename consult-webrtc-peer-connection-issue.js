/**
 * Consult AI experts about WebRTC peer connection offer reuse issue
 */

import { polydev } from './mcp-execution/dist/index.js';

const question = `
WebRTC Signaling Architecture Issue - Need Expert Guidance

CONTEXT:
I'm building a browser-in-browser system where:
1. Frontend (Next.js React) initiates auth flow
2. Backend creates a Firecracker VM (~10s boot time)
3. VM runs WebRTC server for video streaming
4. Frontend connects via WebRTC for low-latency display

CURRENT IMPLEMENTATION (has issues):
1. page.tsx creates RTCPeerConnection #1, generates offer #1, sends to /api/vm/auth
2. Backend stores offer #1 BEFORE creating VM (race condition fixed!)
3. VM boots, fetches offer #1 from backend, generates answer #1
4. Frontend WebRTCViewer component creates RTCPeerConnection #2
5. WebRTCViewer tries to set local description using offer #1 (from PC #1)
6. ERROR: "The SDP does not match the previously generated SDP for this type"

ROOT CAUSE:
- Offer #1 was generated by peer connection #1
- Trying to use it with peer connection #2
- WebRTC rejects this because each RTCPeerConnection generates unique SDPs

CONSTRAINTS:
- MUST store offer BEFORE VM creation (to fix race condition)
- VM boots in ~10-15 seconds
- VM needs the offer to generate answer
- Frontend needs to use the same offer that VM used

QUESTION:
What's the correct architecture? Options I see:

A) Pass RTCPeerConnection instance from page.tsx to WebRTCViewer
   - Complex state management
   - React component mounting timing issues

B) WebRTCViewer creates its own offer, POSTs it, overwrites the first one
   - Risk of timing issues
   - Defeats the race condition fix

C) Don't create offer in page.tsx at all
   - How do we ensure offer exists before VM boots?

D) Some other approach I'm missing?

Please provide the CORRECT WebRTC signaling architecture for this use case.
`;

async function main() {
  try {
    await polydev.initialize();

    console.log('ğŸ¤– Consulting AI experts about WebRTC peer connection architecture...\n');

    const perspectives = await polydev.getPerspectives(question);

    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('AI EXPERT PERSPECTIVES');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
    console.log(perspectives);
    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  } catch (error) {
    console.error('âŒ Error:', error.message);
    process.exit(1);
  }
}

main();
