#!/usr/bin/env node

import { exa, github, polydev } from '/Users/venkat/mcp-execution/dist/index.js';

(async () => {
  console.log('üîç Researching onkernel/kernel-images implementation...\n');

  try {
    await Promise.all([exa.initialize(), github.initialize(), polydev.initialize()]);

    // 1. Get GitHub repository details
    console.log('=== Research 1: onkernel/kernel-images GitHub Repository ===\n');

    const repos = await github.searchRepositories('onkernel kernel-images');

    if (repos.length > 0) {
      console.log('üì¶ Repository Details:');
      repos.slice(0, 3).forEach((repo, idx) => {
        console.log(`\n${idx + 1}. ${repo.full_name}`);
        console.log(`   Stars: ${repo.stargazers_count}`);
        console.log(`   Description: ${repo.description || 'No description'}`);
        console.log(`   URL: ${repo.html_url}`);
        console.log(`   Language: ${repo.language}`);
        console.log(`   Updated: ${repo.updated_at}`);
      });
    }

    console.log('\n---\n');

    // 2. Deep web research on onkernel
    console.log('=== Research 2: onkernel Implementation Details ===\n');

    const onkernelResearch = await exa.search(
      'onkernel kernel-images firecracker VM webrtc implementation',
      {
        numResults: 5,
        type: 'deep',
        livecrawl: 'preferred'
      }
    );

    console.log('üìö Web Research Results:');
    if (onkernelResearch.content && onkernelResearch.content.length > 0) {
      console.log(onkernelResearch.content[0].text.substring(0, 2000));
    } else {
      console.log('No results found');
    }

    console.log('\n---\n');

    // 3. Search for Firecracker + WebRTC implementations
    console.log('=== Research 3: Firecracker WebRTC Implementations ===\n');

    const firecrackerWebRTC = await exa.search(
      'Firecracker VM webrtcbin gstreamer implementation github',
      {
        numResults: 5,
        type: 'deep'
      }
    );

    console.log('üìö Firecracker WebRTC Research:');
    if (firecrackerWebRTC.content && firecrackerWebRTC.content.length > 0) {
      console.log(firecrackerWebRTC.content[0].text.substring(0, 2000));
    }

    console.log('\n---\n');

    // 4. Get expert perspectives
    console.log('=== Expert Consultation: onkernel vs Custom Kernels ===\n');

    const expertAdvice = await polydev.getPerspectives(`
      I'm building a Firecracker-based browser streaming system with WebRTC.

      Current situation:
      - Using custom kernel builds for Firecracker VMs
      - GStreamer pipeline uses UDP streaming (udpsink) instead of webrtcbin
      - No ICE candidates generated by VM (no peer-to-peer WebRTC)
      - Browser WebRTC connection fails because it expects peer-to-peer

      Questions:
      1. Is onkernel/kernel-images (https://github.com/onkernel/kernel-images) a viable solution for Firecracker kernels?
      2. Does onkernel provide pre-built kernels with better networking/WebRTC support?
      3. Should we switch from custom kernels to onkernel, or is our current approach correct?
      4. Is the UDP streaming vs webrtcbin issue related to kernel configuration, or is it purely a GStreamer pipeline problem?
      5. What's the best way to implement true peer-to-peer WebRTC with Firecracker VMs?
    `);

    console.log('ü§ñ Expert Perspectives:');
    console.log(expertAdvice);

    console.log('\n\n‚úÖ Research Complete!');
    console.log('\nüìù Next Steps: Analyze findings and determine if we should use onkernel');

  } catch (error) {
    console.error('‚ùå Error during research:', error.message);
    console.error(error.stack);
  }
})();
